https://wiki.osdev.org/Paging
The remaining bits 9 through 11 are not used by the processor, and are free for the OS to store some of its own accounting information. In addition, when P is not set, the processor ignores the rest of the entry and you can use all remaining 31 bits for extra information, like recording where the page has ended up in swap space.

https://elixir.bootlin.com/linux/latest/source/mm/swap.c
https://elixir.bootlin.com/linux/latest/source/include/linux/mmzone.h#L246
https://elixir.bootlin.com/linux/latest/source/mm/oom_kill.c



Implement OOM killing
â—‹ (using RSS as heuristic)
number of free pages buddy has

mm/oom_kill.c:
/*
* The baseline for the badness score is the proportion of RAM that each
* task's rss, pagetable and swap space use.
*/
points = get_mm_rss(p->mm) + get_mm_counter(p->mm,MM_SWAPENTS) +
mm_pgtables_bytes(p->mm) / PAGE_SIZE;
/* Normalize to oom_score_adj units */
adj = totalpages / 1000;
points += adj;

page 211
3.4.3 The First-In, First-Out (FIFO) Page Replacement Algorithm
As a page replacement algorithm, the same idea is applicable. The operating
system maintains a list of all pages currently in memory, with the most recent arrival at the tail and the least recent arrival at the head. On a page fault, the page at
the head is removed and the new page added to the tail of the list.


yield from kernel task is simple because we have only to save the frame

problem is that we need yield also when cur_task is user
    this is the case when user needs a page
    there are no frames left so we need swap
    buddy starts swap, but we need to yield

user is blocked anyway because it waits for the kernel to give him the page
but kernel should also yield until swap mem is ready

